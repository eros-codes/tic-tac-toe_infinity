<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tic Tac Toe infinity</title>

<link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@300;400;600;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="tic-tac-toe.css">
</head>
<body>
<div class="wrapper" role="application" aria-label="Tic Tac Toe 3x3">
  <aside class="panel" aria-hidden="false">
    <div class="brand">
      <div class="logo">∞</div>
      <div>
        <h1>Tic Tac Toe infinity</h1>
      </div>
    </div>

    <div class="status" aria-live="polite" style="margin-top:12px">
      <div class="turn">
        <div>Turn:</div>
        <div id="currentPlayerChip" class="chip">X</div>
        <div id="statusText" class="muted" style="margin-right:auto">Game is active</div>
      </div>

      <div class="footer" style="margin-top:10px">
        <div style="display:flex;gap:8px">
          <button id="hintBtn" class="btn ghost">Suggest Move</button>
          <button id="swapBtn" class="btn ghost">Swap Player</button>
          <button id="resetBtn" class="btn primary">New Game</button>
        </div>
      </div>
    </div>
  </aside>

  <main class="board-wrap">
    <div class="meta">
      <div class="left">
        <div class="small">Board:</div>
        <div id="metaBoardInfo" class="muted" style="margin-inline-start:8px"></div>
      </div>
      <div class="right">
        <div id="resultMsg" class="msg" style="display:none"></div>
      </div>
    </div>

    <div id="grid" class="grid" role="grid" aria-label="Game board"></div>

    <div style="display:flex;justify-content:space-between;align-items:center;margin-top:12px">
      <div class="muted">Rules: Each player may have up to 3 pieces at once; placing a fourth removes the oldest piece.</div>
      <div style="display:flex;gap:8px">
        <button id="clearHighlights" class="btn ghost">Clear Highlights</button>
      </div>
    </div>
  </main>
</div>

<script>


(() => {
  const BOARD_SIZE = 3;
  const WIN_LENGTH = 3;
  const MAX_PIECES = 3;

  let board = [];
  let currentPlayer = 'X';
  let queues = { X: [], O: [] };
  let moveId = 1;
  let gameOver = false;
  let lastWinningCells = [];

  const gridEl = document.getElementById('grid');
  const currentPlayerChip = document.getElementById('currentPlayerChip');
  const statusText = document.getElementById('statusText');
  const metaBoardInfo = document.getElementById('metaBoardInfo');
  const resultMsg = document.getElementById('resultMsg');
  const hintBtn = document.getElementById('hintBtn');
  const swapBtn = document.getElementById('swapBtn');
  const resetBtn = document.getElementById('resetBtn');
  const clearHighlightsBtn = document.getElementById('clearHighlights');

  function cssVar(name, fallback){
    try {
      const v = getComputedStyle(document.documentElement).getPropertyValue(name);
      return (v && v.trim()) || fallback;
    } catch (err){
      return fallback;
    }
  }

  function initBoard() {
    metaBoardInfo.textContent = `${BOARD_SIZE} × ${BOARD_SIZE}, win length: ${WIN_LENGTH}`;

    board = new Array(BOARD_SIZE);
    for (let r = 0; r < BOARD_SIZE; r++) board[r] = new Array(BOARD_SIZE).fill(null);

    queues = { X: [], O: [] };
    moveId = 1;
    gameOver = false;
    lastWinningCells = [];
    updateMeta();
    renderGrid();
    markOldestForRemoval();
    setStatus('Game reset');
    resultMsg.style.display = 'none';
  }

  function updateMeta() {
    currentPlayerChip.textContent = currentPlayer;
    currentPlayerChip.classList.toggle('o', currentPlayer === 'O');
    currentPlayerChip.classList.toggle('x', currentPlayer === 'X');
  }

  function renderGrid() {
    gridEl.innerHTML = '';
    gridEl.style.gridTemplateColumns = `repeat(${BOARD_SIZE}, 1fr)`;
    gridEl.style.gridTemplateRows = `repeat(${BOARD_SIZE}, 1fr)`;
    for (let r = 0; r < BOARD_SIZE; r++) {
      for (let c = 0; c < BOARD_SIZE; c++) {
        const cell = document.createElement('div');
        cell.className = 'cell empty';
        cell.dataset.r = r;
        cell.dataset.c = c;
        cell.setAttribute('role', 'button');
        cell.tabIndex = 0;
        cell.setAttribute('aria-label', `Cell ${r+1}, ${c+1}`);
        const span = document.createElement('span');
        span.className = 'glyph';
        span.innerHTML = '';
        cell.appendChild(span);

        cell.addEventListener('click', onCellClick);
        cell.addEventListener('keydown', (ev) => {
          const k = ev.key;
          if (k === 'Enter' || k === ' ' || k === 'Spacebar' || ev.code === 'Space') {
            ev.preventDefault();
            onCellClick(ev);
          }
        });

        gridEl.appendChild(cell);
      }
    }
    refreshCells();
  }

  function svgFor(player) {
    const strokeX = cssVar('--accent-x', '#ff6b6b');
    const strokeO = cssVar('--accent-o', '#4fd1c5');
    if (player === 'X') {
      return `<svg viewBox="0 0 100 100" aria-hidden="true" focusable="false">
        <line x1="20" y1="20" x2="80" y2="80" stroke="${strokeX}" stroke-width="10" stroke-linecap="round"/>
        <line x1="80" y1="20" x2="20" y2="80" stroke="${strokeX}" stroke-width="10" stroke-linecap="round"/>
      </svg>`;
    } else {
      return `<svg viewBox="0 0 100 100" aria-hidden="true" focusable="false">
        <circle cx="50" cy="50" r="32" fill="none" stroke="${strokeO}" stroke-width="8" stroke-linecap="round"/>
      </svg>`;
    }
  }

  function refreshCells() {
    const cells = gridEl.children;
    for (let i = 0; i < cells.length; i++) {
      const el = cells[i];
      const r = +el.dataset.r;
      const c = +el.dataset.c;
      const val = board[r][c];
      el.classList.remove('x','o','win','removed','placed','will-remove');
      const span = el.querySelector('span.glyph');
      if (val === null) {
        if (span) span.innerHTML = '';
        el.classList.add('empty');
      } else {
        span.innerHTML = svgFor(val);
        el.classList.remove('empty');
        el.classList.add(val === 'X' ? 'x' : 'o');
        requestAnimationFrame(() => {
          el.classList.add('placed');
          setTimeout(()=> el.classList.remove('placed'), 240);
        });
      }
    }
    highlightWinningCells();
    if (!gameOver) markOldestForRemoval();
  }

  function onCellClick(e) {
    if (gameOver) return;
    const el = e.currentTarget || e.target;
    const r = +el.dataset.r;
    const c = +el.dataset.c;
    if (board[r][c] !== null) { setStatus('Cell occupied — choose an empty cell'); return; }
    playMove(r, c);
  }

  function playMove(r, c) {
    const player = currentPlayer;
    board[r][c] = player;
    const thisMove = { r, c, id: moveId++ };
    queues[player].push(thisMove);

    function finalizeAfterPlacement() {
      refreshCells();
      const winCells = checkWinFrom(player, r, c);
      if (winCells && winCells.length >= WIN_LENGTH) {
        gameOver = true;
        lastWinningCells = winCells;
        for (const el of gridEl.children) el.classList.remove('will-remove');
        refreshCells();
        resultMsg.textContent = `Player ${player} wins!`;
        resultMsg.style.display = 'inline-block';
        setStatus(`Player ${player} wins`, true);
        return;
      }
      currentPlayer = player === 'X' ? 'O' : 'X';
      updateMeta();
      setStatus(`Player ${currentPlayer}'s turn`);
    }

    if (queues[player].length > MAX_PIECES) {
      const old = queues[player].shift();
      animateRemove(old.r, old.c, () => {
        board[old.r][old.c] = null;
        finalizeAfterPlacement();
      });
    } else {
      finalizeAfterPlacement();
    }
  }

  function animateRemove(r, c, cb) {
    const idx = r * BOARD_SIZE + c;
    const el = gridEl.children[idx];
    if (!el) { if (typeof cb === 'function') cb(); return; }
    el.classList.remove('will-remove');
    el.classList.add('removed');
    setTimeout(() => {
      el.classList.remove('removed');
      const span = el.querySelector('span.glyph');
      if (span) span.innerHTML = '';
      el.classList.add('empty');
      el.classList.remove('x','o');
      if (typeof cb === 'function') cb();
      markOldestForRemoval();
    }, 380);
  }

  function setStatus(text, important=false) {
    statusText.textContent = text;
    if (important) statusText.style.color = 'var(--success)';
    else statusText.style.color = 'var(--muted)';
  }

  function checkWinFrom(player, r, c) {
    const dirs = [ [1,0], [0,1], [1,1], [1,-1] ];
    for (const [dx,dy] of dirs) {
      const cells = [[r,c]];
      let i = 1;
      while (true) {
        const nr = r + dx * i, nc = c + dy * i;
        if (!inBounds(nr,nc) || board[nr][nc] !== player) break;
        cells.push([nr,nc]); i++;
      }
      i = 1;
      while (true) {
        const nr = r - dx * i, nc = c - dy * i;
        if (!inBounds(nr,nc) || board[nr][nc] !== player) break;
        cells.unshift([nr,nc]); i++;
      }
      if (cells.length >= WIN_LENGTH) return cells;
    }
    return null;
  }

  function inBounds(r,c){ return r >= 0 && c >= 0 && r < BOARD_SIZE && c < BOARD_SIZE; }

  function highlightWinningCells() {
    for (const el of gridEl.children) el.classList.remove('win');
    if (!lastWinningCells || lastWinningCells.length === 0) return;
    for (const [r,c] of lastWinningCells) {
      const idx = r * BOARD_SIZE + c;
      const el = gridEl.children[idx];
      if (el) el.classList.add('win');
    }
  for (const [r,c] of lastWinningCells) {
    const idx = r * BOARD_SIZE + c;
    const el = gridEl.children[idx];
    if (el && el.classList.contains('will-remove')) {
      el.classList.remove('will-remove');
      el.style.opacity = "1";
      el.style.filter = "none";
    }
  }
  }

  function markOldestForRemoval() {
    for (const el of gridEl.children) el.classList.remove('will-remove');

    ['X','O'].forEach(player => {
      if (queues[player] && queues[player].length >= MAX_PIECES) {
        const oldest = queues[player][0]; // oldest
        if (oldest) {
          const idx = oldest.r * BOARD_SIZE + oldest.c;
          const el = gridEl.children[idx];
          if (el) el.classList.add('will-remove');
        }
      }
    });
  }

  resetBtn.addEventListener('click', () => {
    currentPlayer = 'X';
    initBoard();
  });

  swapBtn.addEventListener('click', () => {
    currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
    updateMeta();
    setStatus(`Turn switched to ${currentPlayer}`);
  });

  clearHighlightsBtn.addEventListener('click', () => {
    lastWinningCells = [];
    highlightWinningCells();
    resultMsg.style.display = 'none';
  });

  hintBtn.addEventListener('click', () => {
    if (gameOver) return setStatus('Game is already over');
    setStatus('Calculating hint...');
    setTimeout(() => {
      const hint = findWinningMove(currentPlayer) || findBlockingMove(currentPlayer) || findCenterOrRandom();
      if (hint) {
        const [r,c] = hint;
        setStatus(`Hint: cell (${r+1}, ${c+1})`);
        const idx = r * BOARD_SIZE + c;
        const el = gridEl.children[idx];
        if (el) {
          el.classList.add('hintPulse');
          setTimeout(()=> el.classList.remove('hintPulse'), 900);
        }
      } else {
        setStatus('No hint available');
      }
    }, 12);
  });

  function findWinningMove(player) {
    for (let r = 0; r < BOARD_SIZE; r++) {
      for (let c = 0; c < BOARD_SIZE; c++) {
        if (board[r][c] !== null) continue;
        board[r][c] = player;
        const win = checkWinFrom(player, r, c);
        board[r][c] = null;
        if (win) return [r,c];
      }
    }
    return null;
  }

  function findBlockingMove(player) {
    const opp = player === 'X' ? 'O' : 'X';
    const m = findWinningMove(opp);
    return m ? m : null;
  }

  function findCenterOrRandom() {
    const center = Math.floor(BOARD_SIZE/2);
    if (board[center][center] === null) return [center,center];
    const empties = [];
    for (let r = 0; r < BOARD_SIZE; r++) for (let c = 0; c < BOARD_SIZE; c++) if (board[r][c]===null) empties.push([r,c]);
    if (empties.length) return empties[Math.floor(Math.random()*empties.length)];
    return null;
  }

  initBoard();

})();
</script>
</body>
</html>